/**
 * Predictive Access API
 * The official Predictive Access API. The Predictive Access API is an HTTP API served by the Predictive Access engine. It is the API used by the Predictive GUI client to communicate with the Access application, so everything the Access client application can do can be done with the API.  # Introduction  The Predictive Access API is built on HTTP. The API is predominantly RESTful and for the most part has predictable resource URL's. It also accepts and returns JSON in the HTTP body. Any HTTP/REST library can be used to perform requests, or the Access Open API specification can be converted into an SDK in any of the 41 supported languages.  # Versioning  The API is usually changed in each release of Access, so API calls are versioned to ensure that existing client implementations do not break.  Starting from Access version 3.0.0, the API version is 3. To lock to this version, the `x-pre-api-version` header should be set to `3`. If no version header is included the call will default to the latest version.  All major releases (i.e. 3.x.x) should support this version of the API, so existing implementations will continue to work even if it is talking to a newer engine. Version compatibility means that requests can be made to the same endpoint specifying different versions and get back different models. If an unsupported version is requested a `400 Bad Request` error will be returned with a message explaining why the request failed.  In previous versions, it was possible to access the API without providing a version. This behavior is now deprecated.  The API uses an open schema model, which means the server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When writing implementation clients, additional properties need to be ignored to ensure they do not break when talking to newer versions.  This documentation is for version 3.0.0 of the API.  # Authentication  Authentication is required for all the API endpoints and must be supplied with each call. Depending on the requirements there are multiple authentication options. Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for the header are `Bearer <session_id>` where `<session_id>` is replaced by the session id (see the `/sessions` documentation). Sessions are only suitable for browser based user sessions. It is strongly recomended that they not be used for application programmatic access as they are designed to dynamically inject human challenge-response tests (such as Captcha). For application API calls use the `Digest <api_key_signature>` where `<api_key_signature>` is replaced by the API key signature. Generating an API signature requires an API key that can be obtained either programmatically or via the web interface.  The following is a Java example of how to generate an API key signatures:  ``` public static String generateSignature(String keyId, String privateKey, String url) {      Long timestamp = Calendar.getInstance().getTimeInMillis() / 1000;     String toSign = String.format(\"[%s][%s]\", timestamp, url);     String hmac = HashUtils.createHmacSha1(toSign, privateKey);      return Base64.getEncoder().encodeToString(String.format(\"[%s]%s[%s]\", keyId, toSign, hmac).getBytes()); } ```  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"code\": 404   \"message\": \"page not found\" } ```  # Filtering  The API has a powerful query filter enabling collections to be searched using comparative filtering. When specifying a filter, the target property should be wrapped using `#{...}` and values should be wrapped using `${...}`. e.g. `#{email} = ${mail@example.com}`.  The following operators are supported: - `#{...} = ${...}` - `#{...} <> ${...}` - `#{...} < ${...}` - `#{...} <= ${...}` - `#{...} > ${...}` - `#{...} >= ${...}` - `contains(#{...},${...})` - `not contains(#{...},${...})`  Additionally the following formatters are supported: - `(...) and (...)` - `(...) or (...)`  Once a filter query has been constructed it must be percentile encoded before been added to the `filter` query parameter in the request.  ``` raw filter -> (contains(#{email},${@exa})) and (#{name} <> ${John}) encoded    -> (contains(%23%7Bemail%7D%2C%24%7B%40exa%7D))%20and%20(%23%7Bname%7D%20%3C%3E%20%24%7BJohn%7D) ```
 *
 * OpenAPI spec version: 3.0.0
 * Contact: support@predictivetech.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {
  HttpClient, HttpHeaders, HttpParams,
  HttpResponse, HttpEvent
} from '@angular/common/http';
import {CustomHttpUrlEncodingCodec} from '../encoder';

import {Observable} from 'rxjs';

import {BatchRequest} from '../model/batchRequest';
import {BatchResponse} from '../model/batchResponse';
import {Role} from '../model/role';
import {Statement} from '../model/statement';

import {BASE_PATH, COLLECTION_FORMATS} from '../variables';
import {Configuration} from '../configuration';


@Injectable()
export class RoleService {

  protected basePath = 'https://dev-api.predictivetech.io/access';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }


  /**
   * add_role_to_federation
   * Add a role to a federation. Note that this function does not create the federation or the role. Both must already exist. This function simply creates a binding between them. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addRoleToFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public addRoleToFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public addRoleToFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public addRoleToFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addRoleToFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling addRoleToFederation.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling addRoleToFederation.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.put<Array<string>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/roles/${encodeURIComponent(String(roleId))}`,
      null,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * add_role_to_group
   * Add a role to a group. Note that this function does not create the group or the role. Both must already exist. This function simply creates a binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param groupId The id of the group.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addRoleToGroup(authorization: string, groupId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public addRoleToGroup(authorization: string, groupId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public addRoleToGroup(authorization: string, groupId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public addRoleToGroup(authorization: string, groupId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addRoleToGroup.');
    }

    if (groupId === null || groupId === undefined) {
      throw new Error('Required parameter groupId was null or undefined when calling addRoleToGroup.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling addRoleToGroup.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.put<Array<string>>(`${this.basePath}/groups/${encodeURIComponent(String(groupId))}/roles/${encodeURIComponent(String(roleId))}`,
      null,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * add_role_to_user
   * Add a role to a user. Note that this function does not create the user or the role. Both must already exist. This function simply creates a binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addRoleToUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public addRoleToUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public addRoleToUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public addRoleToUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addRoleToUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling addRoleToUser.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling addRoleToUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.put<Array<string>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/roles/${encodeURIComponent(String(roleId))}`,
      null,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * create_role
   * Create a new role.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createRole(authorization: string, body: Role, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Role>;
  public createRole(authorization: string, body: Role, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Role>>;
  public createRole(authorization: string, body: Role, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Role>>;
  public createRole(authorization: string, body: Role, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling createRole.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling createRole.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<Role>(`${this.basePath}/roles`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * create_role_statement
   * Creates and adds a statement to a role. Note that this function create the statement and binds it to the role in a single call.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param roleId The id of the role.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createRoleStatement(authorization: string, roleId: string, body: Statement, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Statement>>;
  public createRoleStatement(authorization: string, roleId: string, body: Statement, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Statement>>>;
  public createRoleStatement(authorization: string, roleId: string, body: Statement, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Statement>>>;
  public createRoleStatement(authorization: string, roleId: string, body: Statement, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling createRoleStatement.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling createRoleStatement.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling createRoleStatement.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<Array<Statement>>(`${this.basePath}/roles/${encodeURIComponent(String(roleId))}/statements`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * delete_role
   * Delete a role. All linked users and groups will lose their associated privileges granted by this role.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteRole(authorization: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Role>;
  public deleteRole(authorization: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Role>>;
  public deleteRole(authorization: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Role>>;
  public deleteRole(authorization: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling deleteRole.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling deleteRole.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Role>(`${this.basePath}/roles/${encodeURIComponent(String(roleId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * delete_role_statement
   * Removes and deletes a statement from a role in a single function.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param roleId The id of the role.
   * @param statementId The id of the statement.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteRoleStatement(authorization: string, roleId: string, statementId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Statement>>;
  public deleteRoleStatement(authorization: string, roleId: string, statementId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Statement>>>;
  public deleteRoleStatement(authorization: string, roleId: string, statementId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Statement>>>;
  public deleteRoleStatement(authorization: string, roleId: string, statementId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling deleteRoleStatement.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling deleteRoleStatement.');
    }

    if (statementId === null || statementId === undefined) {
      throw new Error('Required parameter statementId was null or undefined when calling deleteRoleStatement.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Array<Statement>>(`${this.basePath}/roles/${encodeURIComponent(String(roleId))}/statements/${encodeURIComponent(String(statementId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * execute_batch_requests
   * Executes a custom collection of requests in a single call.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param parallel By default, all batch operations will be processed in parallel. This means that there is no guarantee of the execution order. If the order is critical this flag can be set to false and a best effort will be made to execute the requests in the order they appear in the collection.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<BatchResponse>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BatchResponse>>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BatchResponse>>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling executeBatchRequest.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling executeBatchRequest.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (parallel !== undefined && parallel !== null) {
      queryParameters = queryParameters.set('parallel', <any>parallel);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<Array<BatchResponse>>(`${this.basePath}/batches`,
      body,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_federation_roles
   * Retrieve a collection of federation roles. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFederationRoles(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Role>>;
  public getFederationRoles(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Role>>>;
  public getFederationRoles(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Role>>>;
  public getFederationRoles(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getFederationRoles.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling getFederationRoles.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Role>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/roles`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_group_roles
   * Retrieve a collection of group roles.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param groupId The id of the group.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getGroupRoles(authorization: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Role>>;
  public getGroupRoles(authorization: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Role>>>;
  public getGroupRoles(authorization: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Role>>>;
  public getGroupRoles(authorization: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getGroupRoles.');
    }

    if (groupId === null || groupId === undefined) {
      throw new Error('Required parameter groupId was null or undefined when calling getGroupRoles.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Role>>(`${this.basePath}/groups/${encodeURIComponent(String(groupId))}/roles`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_role
   * Retrieve a specific role by its id.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRole(authorization: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'body', reportProgress?: boolean): Observable<Role>;
  public getRole(authorization: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Role>>;
  public getRole(authorization: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Role>>;
  public getRole(authorization: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getRole.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling getRole.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Role>(`${this.basePath}/roles/${encodeURIComponent(String(roleId))}`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_role_blueprint
   * Retrieve a specific role blueprint by its id.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param roleBlueprintId The id of the role blueprint.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRoleBlueprint(authorization: string, roleBlueprintId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'body', reportProgress?: boolean): Observable<Role>;
  public getRoleBlueprint(authorization: string, roleBlueprintId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Role>>;
  public getRoleBlueprint(authorization: string, roleBlueprintId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Role>>;
  public getRoleBlueprint(authorization: string, roleBlueprintId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getRoleBlueprint.');
    }

    if (roleBlueprintId === null || roleBlueprintId === undefined) {
      throw new Error('Required parameter roleBlueprintId was null or undefined when calling getRoleBlueprint.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Role>(`${this.basePath}/blueprints/roles/${encodeURIComponent(String(roleBlueprintId))}`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_role_blueprints
   * Retrieve a collection of role blueprints.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRoleBlueprints(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Role>>;
  public getRoleBlueprints(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Role>>>;
  public getRoleBlueprints(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Role>>>;
  public getRoleBlueprints(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getRoleBlueprints.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Role>>(`${this.basePath}/blueprints/roles`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_roles
   * Retrieve a collection of roles.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRoles(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Role>>;
  public getRoles(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Role>>>;
  public getRoles(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Role>>>;
  public getRoles(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getRoles.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Role>>(`${this.basePath}/roles`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_user_roles
   * Retrieve a collection of user roles.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getUserRoles(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Role>>;
  public getUserRoles(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Role>>>;
  public getUserRoles(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Role>>>;
  public getUserRoles(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getUserRoles.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling getUserRoles.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Role>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/roles`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * modify_role
   * Modify a role. Only supplied properties that differ from the existing will be patched. Note that statements have separate functions. Including or omitting them from this function will have no effect.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param roleId The id of the role.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public modifyRole(authorization: string, roleId: string, body: Role, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Role>;
  public modifyRole(authorization: string, roleId: string, body: Role, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Role>>;
  public modifyRole(authorization: string, roleId: string, body: Role, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Role>>;
  public modifyRole(authorization: string, roleId: string, body: Role, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling modifyRole.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling modifyRole.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling modifyRole.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.patch<Role>(`${this.basePath}/roles/${encodeURIComponent(String(roleId))}`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * modify_role_statement
   * Update a role statement with a new one. The operation is idempotent and the entire model is replaced.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param roleId The id of the role.
   * @param statementId The id of the statement.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public modifyRoleStatement(authorization: string, roleId: string, statementId: string, body: Statement, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Statement>>;
  public modifyRoleStatement(authorization: string, roleId: string, statementId: string, body: Statement, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Statement>>>;
  public modifyRoleStatement(authorization: string, roleId: string, statementId: string, body: Statement, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Statement>>>;
  public modifyRoleStatement(authorization: string, roleId: string, statementId: string, body: Statement, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling modifyRoleStatement.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling modifyRoleStatement.');
    }

    if (statementId === null || statementId === undefined) {
      throw new Error('Required parameter statementId was null or undefined when calling modifyRoleStatement.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling modifyRoleStatement.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<Array<Statement>>(`${this.basePath}/roles/${encodeURIComponent(String(roleId))}/statements/${encodeURIComponent(String(statementId))}`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * remove_role_from_federation
   * Removes a role from a federation. Note that this function does not delete the role, it simply removes the binding between them. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeRoleFromFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public removeRoleFromFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public removeRoleFromFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public removeRoleFromFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeRoleFromFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling removeRoleFromFederation.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling removeRoleFromFederation.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Array<string>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/roles/${encodeURIComponent(String(roleId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * remove_role_from_group
   * Removes a role from a group. Note that this function does not delete the role, it simply removes the binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param groupId The id of the group.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeRoleFromGroup(authorization: string, groupId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public removeRoleFromGroup(authorization: string, groupId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public removeRoleFromGroup(authorization: string, groupId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public removeRoleFromGroup(authorization: string, groupId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeRoleFromGroup.');
    }

    if (groupId === null || groupId === undefined) {
      throw new Error('Required parameter groupId was null or undefined when calling removeRoleFromGroup.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling removeRoleFromGroup.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Array<string>>(`${this.basePath}/groups/${encodeURIComponent(String(groupId))}/roles/${encodeURIComponent(String(roleId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * remove_role_from_user
   * Removes a role from a user. Note that this function does not delete the role, it simply removes the binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeRoleFromUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public removeRoleFromUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public removeRoleFromUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public removeRoleFromUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeRoleFromUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling removeRoleFromUser.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling removeRoleFromUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Array<string>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/roles/${encodeURIComponent(String(roleId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

}

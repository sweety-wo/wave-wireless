/**
 * Predictive Access API
 * The official Predictive Access API. The Predictive Access API is an HTTP API served by the Predictive Access engine. It is the API used by the Predictive GUI client to communicate with the Access application, so everything the Access client application can do can be done with the API.  # Introduction  The Predictive Access API is built on HTTP. The API is predominantly RESTful and for the most part has predictable resource URL's. It also accepts and returns JSON in the HTTP body. Any HTTP/REST library can be used to perform requests, or the Access Open API specification can be converted into an SDK in any of the 41 supported languages.  # Versioning  The API is usually changed in each release of Access, so API calls are versioned to ensure that existing client implementations do not break.  Starting from Access version 3.0.0, the API version is 3. To lock to this version, the `x-pre-api-version` header should be set to `3`. If no version header is included the call will default to the latest version.  All major releases (i.e. 3.x.x) should support this version of the API, so existing implementations will continue to work even if it is talking to a newer engine. Version compatibility means that requests can be made to the same endpoint specifying different versions and get back different models. If an unsupported version is requested a `400 Bad Request` error will be returned with a message explaining why the request failed.  In previous versions, it was possible to access the API without providing a version. This behavior is now deprecated.  The API uses an open schema model, which means the server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When writing implementation clients, additional properties need to be ignored to ensure they do not break when talking to newer versions.  This documentation is for version 3.0.0 of the API.  # Authentication  Authentication is required for all the API endpoints and must be supplied with each call. Depending on the requirements there are multiple authentication options. Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for the header are `Bearer <session_id>` where `<session_id>` is replaced by the session id (see the `/sessions` documentation). Sessions are only suitable for browser based user sessions. It is strongly recomended that they not be used for application programmatic access as they are designed to dynamically inject human challenge-response tests (such as Captcha). For application API calls use the `Digest <api_key_signature>` where `<api_key_signature>` is replaced by the API key signature. Generating an API signature requires an API key that can be obtained either programmatically or via the web interface.  The following is a Java example of how to generate an API key signatures:  ``` public static String generateSignature(String keyId, String privateKey, String url) {      Long timestamp = Calendar.getInstance().getTimeInMillis() / 1000;     String toSign = String.format(\"[%s][%s]\", timestamp, url);     String hmac = HashUtils.createHmacSha1(toSign, privateKey);      return Base64.getEncoder().encodeToString(String.format(\"[%s]%s[%s]\", keyId, toSign, hmac).getBytes()); } ```  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"code\": 404   \"message\": \"page not found\" } ```  # Filtering  The API has a powerful query filter enabling collections to be searched using comparative filtering. When specifying a filter, the target property should be wrapped using `#{...}` and values should be wrapped using `${...}`. e.g. `#{email} = ${mail@example.com}`.  The following operators are supported: - `#{...} = ${...}` - `#{...} <> ${...}` - `#{...} < ${...}` - `#{...} <= ${...}` - `#{...} > ${...}` - `#{...} >= ${...}` - `contains(#{...},${...})` - `not contains(#{...},${...})`  Additionally the following formatters are supported: - `(...) and (...)` - `(...) or (...)`  Once a filter query has been constructed it must be percentile encoded before been added to the `filter` query parameter in the request.  ``` raw filter -> (contains(#{email},${@exa})) and (#{name} <> ${John}) encoded    -> (contains(%23%7Bemail%7D%2C%24%7B%40exa%7D))%20and%20(%23%7Bname%7D%20%3C%3E%20%24%7BJohn%7D) ```
 *
 * OpenAPI spec version: 3.0.0
 * Contact: support@predictivetech.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {
  HttpClient, HttpHeaders, HttpParams,
  HttpResponse, HttpEvent
} from '@angular/common/http';
import {CustomHttpUrlEncodingCodec} from '../encoder';

import {Observable} from 'rxjs';

import {BatchRequest} from '../model/batchRequest';
import {BatchResponse} from '../model/batchResponse';
import {Data} from '../model/data';
import {Form} from '../model/form';
import {Group} from '../model/group';
import {Role} from '../model/role';
import {User} from '../model/user';

import {BASE_PATH, COLLECTION_FORMATS} from '../variables';
import {Configuration} from '../configuration';


@Injectable()
export class UserService {

  protected basePath = 'https://dev-api.predictivetech.io/access';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }


  /**
   * add_group_to_user
   * Add a group to a user. Note that this function does not create the group or the user. Both must already exist. This function simply creates a binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param groupId The id of the group.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addGroupToUser(authorization: string, userId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public addGroupToUser(authorization: string, userId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public addGroupToUser(authorization: string, userId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public addGroupToUser(authorization: string, userId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addGroupToUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling addGroupToUser.');
    }

    if (groupId === null || groupId === undefined) {
      throw new Error('Required parameter groupId was null or undefined when calling addGroupToUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.put<Array<string>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/groups/${encodeURIComponent(String(groupId))}`,
      null,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * add_role_to_user
   * Add a role to a user. Note that this function does not create the user or the role. Both must already exist. This function simply creates a binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addRoleToUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public addRoleToUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public addRoleToUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public addRoleToUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addRoleToUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling addRoleToUser.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling addRoleToUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.put<Array<string>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/roles/${encodeURIComponent(String(roleId))}`,
      null,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * add_user_to_authenticator
   * Add a user to a authenticator. Note that this function does not create the authenticator or the user. Both must already exist. This function simply creates a binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param authenticatorId The id of the authenticator.
   * @param userId The id of the user.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addUserToAuthenticator(authorization: string, authenticatorId: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<User>;
  public addUserToAuthenticator(authorization: string, authenticatorId: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
  public addUserToAuthenticator(authorization: string, authenticatorId: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
  public addUserToAuthenticator(authorization: string, authenticatorId: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addUserToAuthenticator.');
    }

    if (authenticatorId === null || authenticatorId === undefined) {
      throw new Error('Required parameter authenticatorId was null or undefined when calling addUserToAuthenticator.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling addUserToAuthenticator.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.put<User>(`${this.basePath}/authenticators/${encodeURIComponent(String(authenticatorId))}/users/${encodeURIComponent(String(userId))}`,
      null,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * create_user
   * Create a new user.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createUser(authorization: string, body: User, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<User>;
  public createUser(authorization: string, body: User, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
  public createUser(authorization: string, body: User, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
  public createUser(authorization: string, body: User, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling createUser.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling createUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<User>(`${this.basePath}/users`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * delete_user
   * Delete a user.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteUser(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<User>;
  public deleteUser(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
  public deleteUser(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
  public deleteUser(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling deleteUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling deleteUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<User>(`${this.basePath}/users/${encodeURIComponent(String(userId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * execute_batch_requests
   * Executes a custom collection of requests in a single call.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param parallel By default, all batch operations will be processed in parallel. This means that there is no guarantee of the execution order. If the order is critical this flag can be set to false and a best effort will be made to execute the requests in the order they appear in the collection.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<BatchResponse>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BatchResponse>>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BatchResponse>>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling executeBatchRequest.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling executeBatchRequest.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (parallel !== undefined && parallel !== null) {
      queryParameters = queryParameters.set('parallel', <any>parallel);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<Array<BatchResponse>>(`${this.basePath}/batches`,
      body,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_account_users
   * Retrieve a collection of account users.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param accountId The id of the account.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAccountUsers(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<User>>;
  public getAccountUsers(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<User>>>;
  public getAccountUsers(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<User>>>;
  public getAccountUsers(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getAccountUsers.');
    }

    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling getAccountUsers.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<User>>(`${this.basePath}/accounts/${encodeURIComponent(String(accountId))}/users`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_authentication_parameters
   * Obtains the users authenticator form along with a collection of parameters that must be used in the &#x60;create_session&#x60; body.
   * @param type The identifier type used to identify the user. This value can be &#x60;username&#x60; or &#x60;email&#x60;.
   * @param identifier This must be either the users &#x60;email&#x60; or &#x60;username&#x60; depending on the option specified in the &#x60;type&#x60; parameter.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAuthenticationParameters(type: string, identifier: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Form>;
  public getAuthenticationParameters(type: string, identifier: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Form>>;
  public getAuthenticationParameters(type: string, identifier: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Form>>;
  public getAuthenticationParameters(type: string, identifier: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (type === null || type === undefined) {
      throw new Error('Required parameter type was null or undefined when calling getAuthenticationParameters.');
    }

    if (identifier === null || identifier === undefined) {
      throw new Error('Required parameter identifier was null or undefined when calling getAuthenticationParameters.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (type !== undefined && type !== null) {
      queryParameters = queryParameters.set('type', <any>type);
    }
    if (identifier !== undefined && identifier !== null) {
      queryParameters = queryParameters.set('identifier', <any>identifier);
    }

    let headers = this.defaultHeaders;
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Form>(`${this.basePath}/sessions`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_authenticator_users
   * Retrieve a collection of authenticator users.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param authenticatorId The id of the authenticator.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAuthenticatorUsers(authorization: string, authenticatorId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<User>>;
  public getAuthenticatorUsers(authorization: string, authenticatorId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<User>>>;
  public getAuthenticatorUsers(authorization: string, authenticatorId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<User>>>;
  public getAuthenticatorUsers(authorization: string, authenticatorId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getAuthenticatorUsers.');
    }

    if (authenticatorId === null || authenticatorId === undefined) {
      throw new Error('Required parameter authenticatorId was null or undefined when calling getAuthenticatorUsers.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<User>>(`${this.basePath}/authenticators/${encodeURIComponent(String(authenticatorId))}/users`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_group_users
   * Retrieve a collection of group users.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param groupId The id of the group.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getGroupUsers(authorization: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<User>>;
  public getGroupUsers(authorization: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<User>>>;
  public getGroupUsers(authorization: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<User>>>;
  public getGroupUsers(authorization: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getGroupUsers.');
    }

    if (groupId === null || groupId === undefined) {
      throw new Error('Required parameter groupId was null or undefined when calling getGroupUsers.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<User>>(`${this.basePath}/groups/${encodeURIComponent(String(groupId))}/users`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_user
   * Retrieve a specific user by its id.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getUser(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'body', reportProgress?: boolean): Observable<User>;
  public getUser(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
  public getUser(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
  public getUser(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling getUser.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<User>(`${this.basePath}/users/${encodeURIComponent(String(userId))}`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_user_groups
   * Retrieve a collection of user groups.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getUserGroups(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Group>>;
  public getUserGroups(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Group>>>;
  public getUserGroups(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Group>>>;
  public getUserGroups(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getUserGroups.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling getUserGroups.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Group>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/groups`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_user_privileges
   * Retrieve a collection of access privileges for the caller.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param level By default, the response collection will contain service specific privileges. If the level flag is set to &#x60;application&#x60; a condensed application only collection will be returned.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getUserPrivileges(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, level?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
  public getUserPrivileges(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, level?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
  public getUserPrivileges(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, level?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
  public getUserPrivileges(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, level?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getUserPrivileges.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (level !== undefined && level !== null) {
      queryParameters = queryParameters.set('level', <any>level);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<any>(`${this.basePath}/privileges`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_user_roles
   * Retrieve a collection of user roles.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getUserRoles(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Role>>;
  public getUserRoles(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Role>>>;
  public getUserRoles(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Role>>>;
  public getUserRoles(authorization: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getUserRoles.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling getUserRoles.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Role>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/roles`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_users
   * Retrieve a collection of users.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getUsers(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<User>>;
  public getUsers(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<User>>>;
  public getUsers(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<User>>>;
  public getUsers(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getUsers.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<User>>(`${this.basePath}/users`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * modify_user
   * Modify a user. Only supplied properties that differ from the existing will be patched. Note that groups, roles and data have separate functions. Including or omitting them from this function will have no effect.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public modifyUser(authorization: string, userId: string, body: User, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<User>;
  public modifyUser(authorization: string, userId: string, body: User, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
  public modifyUser(authorization: string, userId: string, body: User, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
  public modifyUser(authorization: string, userId: string, body: User, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling modifyUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling modifyUser.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling modifyUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.patch<User>(`${this.basePath}/users/${encodeURIComponent(String(userId))}`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * remove_group_from_user
   * Removes a group from a user. Note that this function does not delete the group, it simply removes the binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param groupId The id of the group.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeGroupFromUser(authorization: string, userId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public removeGroupFromUser(authorization: string, userId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public removeGroupFromUser(authorization: string, userId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public removeGroupFromUser(authorization: string, userId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeGroupFromUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling removeGroupFromUser.');
    }

    if (groupId === null || groupId === undefined) {
      throw new Error('Required parameter groupId was null or undefined when calling removeGroupFromUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Array<string>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/groups/${encodeURIComponent(String(groupId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * remove_role_from_user
   * Removes a role from a user. Note that this function does not delete the role, it simply removes the binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeRoleFromUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public removeRoleFromUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public removeRoleFromUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public removeRoleFromUser(authorization: string, userId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeRoleFromUser.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling removeRoleFromUser.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling removeRoleFromUser.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Array<string>>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/roles/${encodeURIComponent(String(roleId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * remove_user_from_authenticator
   * Removes a user from a authenticator. Note that this function does not delete the user, it simply removes the binding between them.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param authenticatorId The id of the authenticator.
   * @param userId The id of the user.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeUserFromAuthenticator(authorization: string, authenticatorId: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<User>;
  public removeUserFromAuthenticator(authorization: string, authenticatorId: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
  public removeUserFromAuthenticator(authorization: string, authenticatorId: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
  public removeUserFromAuthenticator(authorization: string, authenticatorId: string, userId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeUserFromAuthenticator.');
    }

    if (authenticatorId === null || authenticatorId === undefined) {
      throw new Error('Required parameter authenticatorId was null or undefined when calling removeUserFromAuthenticator.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling removeUserFromAuthenticator.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<User>(`${this.basePath}/authenticators/${encodeURIComponent(String(authenticatorId))}/users/${encodeURIComponent(String(userId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * update_user_data
   * Update a user data with a new one. The operation is idempotent and the entire model is replaced. To set the data object as empty an object with a single empty KVP must be supplied &#x60;{ \&quot;\&quot;: [] }&#x60;
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param userId The id of the user.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateUserData(authorization: string, userId: string, body: Data, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Data>;
  public updateUserData(authorization: string, userId: string, body: Data, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Data>>;
  public updateUserData(authorization: string, userId: string, body: Data, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Data>>;
  public updateUserData(authorization: string, userId: string, body: Data, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling updateUserData.');
    }

    if (userId === null || userId === undefined) {
      throw new Error('Required parameter userId was null or undefined when calling updateUserData.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling updateUserData.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<Data>(`${this.basePath}/users/${encodeURIComponent(String(userId))}/datas`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

}

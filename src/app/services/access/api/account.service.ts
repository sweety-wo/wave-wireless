/**
 * Predictive Access API
 * The official Predictive Access API. The Predictive Access API is an HTTP API served by the Predictive Access engine. It is the API used by the Predictive GUI client to communicate with the Access application, so everything the Access client application can do can be done with the API.  # Introduction  The Predictive Access API is built on HTTP. The API is predominantly RESTful and for the most part has predictable resource URL's. It also accepts and returns JSON in the HTTP body. Any HTTP/REST library can be used to perform requests, or the Access Open API specification can be converted into an SDK in any of the 41 supported languages.  # Versioning  The API is usually changed in each release of Access, so API calls are versioned to ensure that existing client implementations do not break.  Starting from Access version 3.0.0, the API version is 3. To lock to this version, the `x-pre-api-version` header should be set to `3`. If no version header is included the call will default to the latest version.  All major releases (i.e. 3.x.x) should support this version of the API, so existing implementations will continue to work even if it is talking to a newer engine. Version compatibility means that requests can be made to the same endpoint specifying different versions and get back different models. If an unsupported version is requested a `400 Bad Request` error will be returned with a message explaining why the request failed.  In previous versions, it was possible to access the API without providing a version. This behavior is now deprecated.  The API uses an open schema model, which means the server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When writing implementation clients, additional properties need to be ignored to ensure they do not break when talking to newer versions.  This documentation is for version 3.0.0 of the API.  # Authentication  Authentication is required for all the API endpoints and must be supplied with each call. Depending on the requirements there are multiple authentication options. Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for the header are `Bearer <session_id>` where `<session_id>` is replaced by the session id (see the `/sessions` documentation). Sessions are only suitable for browser based user sessions. It is strongly recomended that they not be used for application programmatic access as they are designed to dynamically inject human challenge-response tests (such as Captcha). For application API calls use the `Digest <api_key_signature>` where `<api_key_signature>` is replaced by the API key signature. Generating an API signature requires an API key that can be obtained either programmatically or via the web interface.  The following is a Java example of how to generate an API key signatures:  ``` public static String generateSignature(String keyId, String privateKey, String url) {      Long timestamp = Calendar.getInstance().getTimeInMillis() / 1000;     String toSign = String.format(\"[%s][%s]\", timestamp, url);     String hmac = HashUtils.createHmacSha1(toSign, privateKey);      return Base64.getEncoder().encodeToString(String.format(\"[%s]%s[%s]\", keyId, toSign, hmac).getBytes()); } ```  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"code\": 404   \"message\": \"page not found\" } ```  # Filtering  The API has a powerful query filter enabling collections to be searched using comparative filtering. When specifying a filter, the target property should be wrapped using `#{...}` and values should be wrapped using `${...}`. e.g. `#{email} = ${mail@example.com}`.  The following operators are supported: - `#{...} = ${...}` - `#{...} <> ${...}` - `#{...} < ${...}` - `#{...} <= ${...}` - `#{...} > ${...}` - `#{...} >= ${...}` - `contains(#{...},${...})` - `not contains(#{...},${...})`  Additionally the following formatters are supported: - `(...) and (...)` - `(...) or (...)`  Once a filter query has been constructed it must be percentile encoded before been added to the `filter` query parameter in the request.  ``` raw filter -> (contains(#{email},${@exa})) and (#{name} <> ${John}) encoded    -> (contains(%23%7Bemail%7D%2C%24%7B%40exa%7D))%20and%20(%23%7Bname%7D%20%3C%3E%20%24%7BJohn%7D) ```
 *
 * OpenAPI spec version: 3.0.0
 * Contact: support@predictivetech.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {
  HttpClient, HttpHeaders, HttpParams,
  HttpResponse, HttpEvent
} from '@angular/common/http';
import {CustomHttpUrlEncodingCodec} from '../encoder';

import {Observable} from 'rxjs';

import {Account} from '../model/account';
import {BatchRequest} from '../model/batchRequest';
import {BatchResponse} from '../model/batchResponse';
import {Data} from '../model/data';
import {NewAccount} from '../model/newAccount';
import {User} from '../model/user';

import {BASE_PATH, COLLECTION_FORMATS} from '../variables';
import {Configuration} from '../configuration';


@Injectable()
export class AccountService {

  protected basePath = 'https://dev-api.predictivetech.io/access';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }


  /**
   * create_account
   * Create a new account with a root user. Both actions are considered to be part of the same atomic operation. If either fail, the request will return an error and neither resource will be created.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createAccount(authorization: string, body: NewAccount, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<NewAccount>;
  public createAccount(authorization: string, body: NewAccount, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NewAccount>>;
  public createAccount(authorization: string, body: NewAccount, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NewAccount>>;
  public createAccount(authorization: string, body: NewAccount, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling createAccount.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling createAccount.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<NewAccount>(`${this.basePath}/accounts`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * delete_account
   * Delete an account along with all its associated resource and users.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param accountId The id of the account.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteAccount(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Account>;
  public deleteAccount(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Account>>;
  public deleteAccount(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Account>>;
  public deleteAccount(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling deleteAccount.');
    }

    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling deleteAccount.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Account>(`${this.basePath}/accounts/${encodeURIComponent(String(accountId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * execute_batch_requests
   * Executes a custom collection of requests in a single call.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param parallel By default, all batch operations will be processed in parallel. This means that there is no guarantee of the execution order. If the order is critical this flag can be set to false and a best effort will be made to execute the requests in the order they appear in the collection.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<BatchResponse>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BatchResponse>>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BatchResponse>>>;
  public executeBatchRequest(authorization: string, body: BatchRequest, xPreApiFederation?: string, xPreApiVersion?: string, parallel?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling executeBatchRequest.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling executeBatchRequest.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (parallel !== undefined && parallel !== null) {
      queryParameters = queryParameters.set('parallel', <any>parallel);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<Array<BatchResponse>>(`${this.basePath}/batches`,
      body,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_account
   * Retrieve a specific account by its id.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param accountId The id of the account.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAccount(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'body', reportProgress?: boolean): Observable<Account>;
  public getAccount(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Account>>;
  public getAccount(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Account>>;
  public getAccount(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getAccount.');
    }

    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling getAccount.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Account>(`${this.basePath}/accounts/${encodeURIComponent(String(accountId))}`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_account_users
   * Retrieve a collection of account users.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param accountId The id of the account.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAccountUsers(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<User>>;
  public getAccountUsers(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<User>>>;
  public getAccountUsers(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<User>>>;
  public getAccountUsers(authorization: string, accountId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getAccountUsers.');
    }

    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling getAccountUsers.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<User>>(`${this.basePath}/accounts/${encodeURIComponent(String(accountId))}/users`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_accounts
   * Retrieve a collection of accounts.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAccounts(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Account>>;
  public getAccounts(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Account>>>;
  public getAccounts(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Account>>>;
  public getAccounts(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getAccounts.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Account>>(`${this.basePath}/accounts`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * modify_account
   * Modify an account. Only supplied properties that differ from the existing will be patched.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param accountId The id of the account.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public modifyAccount(authorization: string, accountId: string, body: Account, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Account>;
  public modifyAccount(authorization: string, accountId: string, body: Account, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Account>>;
  public modifyAccount(authorization: string, accountId: string, body: Account, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Account>>;
  public modifyAccount(authorization: string, accountId: string, body: Account, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling modifyAccount.');
    }

    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling modifyAccount.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling modifyAccount.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.patch<Account>(`${this.basePath}/accounts/${encodeURIComponent(String(accountId))}`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * update_account_data
   * Update an account data with a new one. The operation is idempotent and the entire model is replaced. To set the data object as empty an object with a single empty KVP must be supplied &#x60;{ \&quot;\&quot;: [] }&#x60;
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param accountId The id of the account.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateAccountData(authorization: string, accountId: string, body: Data, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Data>;
  public updateAccountData(authorization: string, accountId: string, body: Data, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Data>>;
  public updateAccountData(authorization: string, accountId: string, body: Data, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Data>>;
  public updateAccountData(authorization: string, accountId: string, body: Data, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling updateAccountData.');
    }

    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling updateAccountData.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling updateAccountData.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<Data>(`${this.basePath}/accounts/${encodeURIComponent(String(accountId))}/datas`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

}

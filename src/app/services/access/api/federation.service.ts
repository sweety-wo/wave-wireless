/**
 * Predictive Access API
 * The official Predictive Access API. The Predictive Access API is an HTTP API served by the Predictive Access engine. It is the API used by the Predictive GUI client to communicate with the Access application, so everything the Access client application can do can be done with the API.  # Introduction  The Predictive Access API is built on HTTP. The API is predominantly RESTful and for the most part has predictable resource URL's. It also accepts and returns JSON in the HTTP body. Any HTTP/REST library can be used to perform requests, or the Access Open API specification can be converted into an SDK in any of the 41 supported languages.  # Versioning  The API is usually changed in each release of Access, so API calls are versioned to ensure that existing client implementations do not break.  Starting from Access version 3.0.0, the API version is 3. To lock to this version, the `x-pre-api-version` header should be set to `3`. If no version header is included the call will default to the latest version.  All major releases (i.e. 3.x.x) should support this version of the API, so existing implementations will continue to work even if it is talking to a newer engine. Version compatibility means that requests can be made to the same endpoint specifying different versions and get back different models. If an unsupported version is requested a `400 Bad Request` error will be returned with a message explaining why the request failed.  In previous versions, it was possible to access the API without providing a version. This behavior is now deprecated.  The API uses an open schema model, which means the server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When writing implementation clients, additional properties need to be ignored to ensure they do not break when talking to newer versions.  This documentation is for version 3.0.0 of the API.  # Authentication  Authentication is required for all the API endpoints and must be supplied with each call. Depending on the requirements there are multiple authentication options. Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for the header are `Bearer <session_id>` where `<session_id>` is replaced by the session id (see the `/sessions` documentation). Sessions are only suitable for browser based user sessions. It is strongly recomended that they not be used for application programmatic access as they are designed to dynamically inject human challenge-response tests (such as Captcha). For application API calls use the `Digest <api_key_signature>` where `<api_key_signature>` is replaced by the API key signature. Generating an API signature requires an API key that can be obtained either programmatically or via the web interface.  The following is a Java example of how to generate an API key signatures:  ``` public static String generateSignature(String keyId, String privateKey, String url) {      Long timestamp = Calendar.getInstance().getTimeInMillis() / 1000;     String toSign = String.format(\"[%s][%s]\", timestamp, url);     String hmac = HashUtils.createHmacSha1(toSign, privateKey);      return Base64.getEncoder().encodeToString(String.format(\"[%s]%s[%s]\", keyId, toSign, hmac).getBytes()); } ```  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"code\": 404   \"message\": \"page not found\" } ```  # Filtering  The API has a powerful query filter enabling collections to be searched using comparative filtering. When specifying a filter, the target property should be wrapped using `#{...}` and values should be wrapped using `${...}`. e.g. `#{email} = ${mail@example.com}`.  The following operators are supported: - `#{...} = ${...}` - `#{...} <> ${...}` - `#{...} < ${...}` - `#{...} <= ${...}` - `#{...} > ${...}` - `#{...} >= ${...}` - `contains(#{...},${...})` - `not contains(#{...},${...})`  Additionally the following formatters are supported: - `(...) and (...)` - `(...) or (...)`  Once a filter query has been constructed it must be percentile encoded before been added to the `filter` query parameter in the request.  ``` raw filter -> (contains(#{email},${@exa})) and (#{name} <> ${John}) encoded    -> (contains(%23%7Bemail%7D%2C%24%7B%40exa%7D))%20and%20(%23%7Bname%7D%20%3C%3E%20%24%7BJohn%7D) ```
 *
 * OpenAPI spec version: 3.0.0
 * Contact: support@predictivetech.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {
  HttpClient, HttpHeaders, HttpParams,
  HttpResponse, HttpEvent
} from '@angular/common/http';
import {CustomHttpUrlEncodingCodec} from '../encoder';

import {Observable} from 'rxjs';

import {Federation} from '../model/federation';
import {Group} from '../model/group';
import {Role} from '../model/role';

import {BASE_PATH, COLLECTION_FORMATS} from '../variables';
import {Configuration} from '../configuration';


@Injectable()
export class FederationService {

  protected basePath = 'https://dev-api.predictivetech.io/access';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }


  /**
   * add_group_to_federation
   * Add a group to a federation. Note that this function does not create the group or the federation. Both must already exist. This function simply creates a binding between them. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param groupId The id of the group.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addGroupToFederation(authorization: string, federationId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public addGroupToFederation(authorization: string, federationId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public addGroupToFederation(authorization: string, federationId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public addGroupToFederation(authorization: string, federationId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addGroupToFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling addGroupToFederation.');
    }

    if (groupId === null || groupId === undefined) {
      throw new Error('Required parameter groupId was null or undefined when calling addGroupToFederation.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.put<Array<string>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/groups/${encodeURIComponent(String(groupId))}`,
      null,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * add_role_to_federation
   * Add a role to a federation. Note that this function does not create the federation or the role. Both must already exist. This function simply creates a binding between them. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addRoleToFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public addRoleToFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public addRoleToFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public addRoleToFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling addRoleToFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling addRoleToFederation.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling addRoleToFederation.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.put<Array<string>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/roles/${encodeURIComponent(String(roleId))}`,
      null,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * create_federation
   * Create a new federation.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param accountId The id of the outbound account being granted access to the federation.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createFederation(authorization: string, accountId: string, body: Federation, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Federation>;
  public createFederation(authorization: string, accountId: string, body: Federation, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Federation>>;
  public createFederation(authorization: string, accountId: string, body: Federation, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Federation>>;
  public createFederation(authorization: string, accountId: string, body: Federation, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling createFederation.');
    }

    if (accountId === null || accountId === undefined) {
      throw new Error('Required parameter accountId was null or undefined when calling createFederation.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling createFederation.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (accountId !== undefined && accountId !== null) {
      queryParameters = queryParameters.set('accountId', <any>accountId);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<Federation>(`${this.basePath}/federations`,
      body,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * delete_federation
   * Delete a federation.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteFederation(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Federation>;
  public deleteFederation(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Federation>>;
  public deleteFederation(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Federation>>;
  public deleteFederation(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling deleteFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling deleteFederation.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Federation>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_federation
   * Retrieve a specific federation by its id.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFederation(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'body', reportProgress?: boolean): Observable<Federation>;
  public getFederation(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Federation>>;
  public getFederation(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Federation>>;
  public getFederation(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, fields?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling getFederation.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Federation>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_federation_groups
   * Retrieve a collection of federation groups. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFederationGroups(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Group>>;
  public getFederationGroups(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Group>>>;
  public getFederationGroups(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Group>>>;
  public getFederationGroups(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getFederationGroups.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling getFederationGroups.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Group>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/groups`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_federation_roles
   * Retrieve a collection of federation roles. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFederationRoles(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Role>>;
  public getFederationRoles(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Role>>>;
  public getFederationRoles(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Role>>>;
  public getFederationRoles(authorization: string, federationId: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getFederationRoles.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling getFederationRoles.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Role>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/roles`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * get_federations
   * Retrieve a collection of federations.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param sort The field name that should be used to sort the resulting collection. This value must exist as a property of the response object otherwise a default sort will be applied.
   * @param page For paginated requests, this value can be set to specify the page number to return. If the value is larger than the maximum pages available, the last page will be returned. If a value less than 1 is specified, the first page will be returned. Collection information is available in the headers.
   * @param perPage For paginated requests, this value can be set to specify the number of records to include in a single page. If a value of less than 1 is specified, a best effort to return the whole collection will be made. This is not guaranteed and the response headers should be checked to obtain any additional pages.
   * @param fields To reduce bandwidth and increase response speeds on slow networks it is possible to request that only partial response models be returned. By specifying a comma separated list of required fields, the response object will restrict the model to only include those fields in the response. These values must exist as part of the object. The id field will always be returned regardless.
   * @param filter A URL encoded query filter. For more information on filter formats, see the Filtering documentation above.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFederations(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Federation>>;
  public getFederations(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Federation>>>;
  public getFederations(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Federation>>>;
  public getFederations(authorization: string, xPreApiFederation?: string, xPreApiVersion?: string, sort?: string, page?: number, perPage?: number, fields?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling getFederations.');
    }


    let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
    if (sort !== undefined && sort !== null) {
      queryParameters = queryParameters.set('sort', <any>sort);
    }
    if (page !== undefined && page !== null) {
      queryParameters = queryParameters.set('page', <any>page);
    }
    if (perPage !== undefined && perPage !== null) {
      queryParameters = queryParameters.set('perPage', <any>perPage);
    }
    if (fields !== undefined && fields !== null) {
      queryParameters = queryParameters.set('fields', <any>fields);
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = queryParameters.set('filter', <any>filter);
    }

    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.get<Array<Federation>>(`${this.basePath}/federations`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * modify_federation
   * Modify a federation. Only supplied properties that differ from the existing will be patched. Note that groups and roles have separate functions. Including or omitting them from this function will have no effect.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param body
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public modifyFederation(authorization: string, federationId: string, body: Federation, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Federation>;
  public modifyFederation(authorization: string, federationId: string, body: Federation, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Federation>>;
  public modifyFederation(authorization: string, federationId: string, body: Federation, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Federation>>;
  public modifyFederation(authorization: string, federationId: string, body: Federation, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling modifyFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling modifyFederation.');
    }

    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling modifyFederation.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.patch<Federation>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}`,
      body,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * remove_group_from_federation
   * Removes a group from a federation. Note that this function does not delete the group, it simply removes the binding between them. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param groupId The id of the group.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeGroupFromFederation(authorization: string, federationId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public removeGroupFromFederation(authorization: string, federationId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public removeGroupFromFederation(authorization: string, federationId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public removeGroupFromFederation(authorization: string, federationId: string, groupId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeGroupFromFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling removeGroupFromFederation.');
    }

    if (groupId === null || groupId === undefined) {
      throw new Error('Required parameter groupId was null or undefined when calling removeGroupFromFederation.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Array<string>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/groups/${encodeURIComponent(String(groupId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * remove_role_from_federation
   * Removes a role from a federation. Note that this function does not delete the role, it simply removes the binding between them. This function is only available to the &#x60;INBOUND&#x60; federation account.
   * @param authorization Due to the limitations of the Open API 2 specification, authorization headers are supplied on a per function basis. The acceptable formats for this header are &#x60;Bearer &lt;session_id&gt;&#x60; where &#x60;&lt;session_id&gt;&#x60; is replaced by the session id or &#x60;Digest &lt;api_key_signature&gt;&#x60; where &#x60;&lt;api_key_signature&gt;&#x60; is replaced by the API key signature.
   * @param federationId The id of the federation.
   * @param roleId The id of the role.
   * @param xPreApiFederation If a federation has been established between two accounts the outbound federation id can be used to make a marshalled request to the outbound account. Providing the principal has sufficient privileges to invoke the federation, the roles established by the inbound federation will be granted for the request.
   * @param xPreApiVersion The version of the API endpoint to request. For more information, see the documentation on &#x60;Versioning&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeRoleFromFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
  public removeRoleFromFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
  public removeRoleFromFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
  public removeRoleFromFederation(authorization: string, federationId: string, roleId: string, xPreApiFederation?: string, xPreApiVersion?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

    if (authorization === null || authorization === undefined) {
      throw new Error('Required parameter authorization was null or undefined when calling removeRoleFromFederation.');
    }

    if (federationId === null || federationId === undefined) {
      throw new Error('Required parameter federationId was null or undefined when calling removeRoleFromFederation.');
    }

    if (roleId === null || roleId === undefined) {
      throw new Error('Required parameter roleId was null or undefined when calling removeRoleFromFederation.');
    }


    let headers = this.defaultHeaders;
    if (authorization !== undefined && authorization !== null) {
      headers = headers.set('authorization', String(authorization));
    }
    if (xPreApiFederation !== undefined && xPreApiFederation !== null) {
      headers = headers.set('x-pre-api-federation', String(xPreApiFederation));
    }
    if (xPreApiVersion !== undefined && xPreApiVersion !== null) {
      headers = headers.set('x-pre-api-version', String(xPreApiVersion));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [
      'application/json'
    ];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.delete<Array<string>>(`${this.basePath}/federations/${encodeURIComponent(String(federationId))}/roles/${encodeURIComponent(String(roleId))}`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress
      }
    );
  }

}
